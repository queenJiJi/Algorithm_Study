# 파라메트릭 서치
# 파라메트릭 서치 = '최적화된 문제를 결정문제('예' 혹은 '아니오')로 바꾸어 해결하는 기법' 입니다
# 예시 : 특정한 조건을 만족하는 가장 알맞은 값을 빠르게 찾는 최적화 문제
# 일반적으로 코딩 테스트에서 파라메트릭 서치 문제는 '이진 탐색을 이용하여 해결' 할 수 있습니다.


# 문제: 떡볶이 떡 만들기
# 아이디어: 적절한 높이를 찾을 때 가지 이진탐색을 수행하여 높이H를 반복해서 조정하면 됨
# '현재 이 높이로 자르면 조건을 만족할 수 있는가?'를 확인한 뒤에
# '조건의 만족여부(예 혹은 아니오)에 따라서 '탐색 범위를 좁혀서 해결'
# 절단기의 높이는 0부터 10억 까지의 정수 중 하나임
# 이렇게 큰 탐색 범위를 보면 가장 먼저 '이진탐색'을 떠올려야함!!!!

# [ 내가 푼 SOLUTION ]
# 이건 근데 선형 탐색이므로 실제 코테에선 시간초과 뜰 수 있음
# 이진 탐색을 떠올렸어야함
n, m = map(int, input().split())
arr = list(map(int, input().split()))

# valarr = []
# count = 0
# for i in range(min(arr), max(arr)+1):
#     for j in arr:
#         if i > j:
#             continue
#         count += abs(i-j)
#     if count <= m:
#         valarr.append(i)
#     count = 0
# print(min(valarr))

# 정답
# 아이디어 :
# step1:시작점: 0, 끝점: 19, 중간점(=우리가 자르고자하는 기준 즉 절단기):9
# 이때 필요한 떡의 크기:m =6인데, 중간점(9)으로 잘랐을 경우
#  잘린떡의 길이는 10+6+1+8 > m 이므로 최소한 원하는 떡의 길이 이상이므로 해당 중간점 저장
# step2: 중간점이 더 높아도(=잘린 떡의 길이가 더 작어져도) 되니까
# 시작점을 중간점+1로 설정-> 시작점:10, 끝점: 19, 중간점: 14
# 이것도 잘린 떡의 길이가 5+1+3 > m 이므로 해당 중간점 저장
# step3: 다시한번 중간점을 더 높이기-> 시작점: 중간점+1= 15, 끝점:19, 중간점:17
# 이것의 잘린떡의 길이: 2<m 이므로 결과 저장하지 않음
# step4: 이제 다시 끝점을 중간점-1로 설정: 시작점: 15, 끝점: 16, 중간점: 15
# 이것의 잘린 떡의 길이: 4+2=m이므로 해당 중간점 저장

# 이러한 이진탐색과정을 반복하면 정답을 도출 할 수 있음
# 중간점의 값은 시간이 지날수록 '최적화된 값'이 되기 때문에, 과정을 반복하면서 얻을 수 있는
# 떡의 길이 합 >= 필요한 떡의 길이 일떄마다 중간점의 값을 기록하면 됨

# [ SOLUTION ]
start = 0
end = max(arr)
# 이진탐색 수행(반복문)
result = 0
while (start <= end):
    total = 0
    mid = (start+end)//2
    for x in arr:
        # 잘랐을 때의 떡의 양 계산
        if x > mid:
            total += (x-mid)
    # 떡의 양이 부족한 경우 더 많이 자르기 (왼쪽 부분 탐색)
    if total < m:
        end = mid-1
    # 떡의 양이 충분한 경우 덜 자르기(오른쪽 부분 탐색)
    else:
        result = mid  # 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록
        start = mid+1

# 정답 출력
print(result)

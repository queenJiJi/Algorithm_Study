# 삽입정렬: 처리되지 않은 데이터를 하나씩 골라 '적절한 위치에 삽입' 합니다.
# 정렬되어있는 그  왼쪽 원소들과 비교를 해서 자기가 더 큰지, 작은지 확인해서
# 그 크기에 맞는 위치에 들어감
# 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효육적으로 동작


arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
# 일단 맨앞은 고정 시키고 그 다음 원소 부터 맨 앞 원소까지 비교하며 들어감
for i in range(1, len(arr)):
    for j in range(i, 0, -1):  # 인텍스 i부터 맨앞까지 1씩 감소하며 반복하는 문법
        if arr[j] < arr[j-1]:  # 한칸씩 왼쪽으로 이동
            arr[j], arr[j-1] = arr[j-1], arr[j]  # swap
        else:  # 그 앞에 원소들을 비교해봤는데 자기보다 작으면 그 위치에 멈춤
            break
print(arr)


# 삽입 정렬의 시간 복잡도는 O(N^2)이며,
# 선택 정렬과 마찬가지로 반복문이 두번 중첩되어 사용됩니다.
# 삽입 정렬은 '현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작' 합니다.
#   최선의 경우 O(N)의 시간 복잡도를 가집니다
#   이미 정렬되어있는 상태에서 다시 삽입 정렬을 수행하면 어떻게 될까?
#   ->이미 정렬되어 있는 상태니까 그 전으로 돌아가고 뭐시기 할 필요없이 break에 걸려서 O(N)시간복잡도 가짐

# 탑다운 VS 보텀업
# 탑다운(메모이제이션) 방식은 '하향식' 이라고도 함
#   구현과정에서 '재귀함수'를 활용- 즉, 큰 문제를 해결하기 위해서 작은 문제들을 재귀적으로 호출하여
#   작은 문제들이 모두 해결되었을때, 큰 문제에 대한 답까지 얻을 수 있도록 코드 작성
# 보텀업 방식은 '상향식' 이라고도 함
#   아래쪽에서부터 작은 문제를 하나씩 해결 해 나가면서, 먼저 계산한 결과값을 활용해서
#   다음 문제까지 차례대로 해결한 다는 것이 특징
#   따라서, 보텀업 방식을 활용할때는 '반복문'을 이용

# 다이나믹 프로그래밍의 전형적인 형태는 '보텀업' 방식임
#  결과 저장용 리스트는 'DP 테이블'이라고 부름

# 엄밀히 말하면 메모이제이션은 '이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미'
# 따라서 메모이제이션은 dp에 국한된 개념은 아님
# 한번 계산된 결과를 담아 놓기만 하고 dp을 위해 활용하지 않을 수도 있음

# DP를 활용한 피보나치 수열 해결 방법

# 1. 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0]*100


def fibo(x):
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    #  아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]


print(fibo(99))

# 2. 피보나치 함수를 반복문으로 구현(보텀업 다이나믹 프로그래밍)
d = [0]*100
# 첫번째 피보나치 수와 두번째 피보나치 수는 1
d[1] = 1  # 점화식의 초기값 초기화
d[2] = 1  # 점화식의 초기값 초기화
n = 99

# 피보나치 함수 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
    d[i] = d[i-1]+d[i-2]  # 점화식 그대로 기입
    # 작은 문제들을 해결하고 그 해결한 값을 기본으로 큰 계산도 수행하는 방식(보텀업)
print(d[n])
